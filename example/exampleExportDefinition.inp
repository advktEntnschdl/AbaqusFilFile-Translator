** We have a UEL, which has 4 nodes with displacement and nonlocal damage DOFs,
*defineElementType, element=U001, shape=quad4
** .. and a standard Abaqus CPS4, which also has also 4 nodes
*defineElementType, element=CPS4, shape=quad4
**
** NODAL VARIABLES
**
** Ensight expects that vectors have 3 components, but Abaqus writes only 2 for 2D. So we zero fill the z direction, by specifying dimensions=3
*ensightPerNodeVariable, set=ALL, exportName=nodeDisplacements, result=U, dimensions=3

** reaction forces are written only at the boundary, so we need to specificy that all missing values at interior nodes are zeroed
*ensightPerNodeVariable, set=ALL, exportName=nodeReactionForces, result=RF, dimensions=3, fillMissingValues=0.0
**

** nonlocal damage is a scalar, so no problem here
*ensightPerNodeVariable, set=SECCONC, exportName=nodeAlphaDNonLocal, result=NT, 
**
**
** ELEMENTAL VARIABLES
**
** convert the UEL SDVs (which contain material SDVs + stresses and strains). 
** we need to define the periodical pattern of 4 gauss points within the SDVs, seperated by a data distance of 18, and with an initial offset of 0
** of course, this is dependent on the UEL!
**
** assumed layout of the SDV vector per UEL:
** [ [ qpInitialOffset ... ] [ DATA of QP1 ...  qpDistance -> ] [ DATA of QP 2 ... qpDistance -> ] ]

*UELSDVToQuadraturePoints, set=SECCONC, destination=ConcUelSDVs, qpCount=4, qpInitialOffset=0, qpDistance=18

** furthermore, we may want to compute the average over all SDVs
*computeAverageOverQuadraturePoints, set=SECCONC, result=ConcUelSDVs
**
** Scalar Variables are accessed in the SDV field by means of their index ....
*ensightPerElementVariable, set=SECCONC, exportName=alphaP, result=ConcUelSDVs, location=qps, which='1;2;3;4',  values=0
*ensightPerElementVariable, set=SECCONC, exportName=alphaP, result=ConcUelSDVs, location=computed, which=average,  values=0
*ensightPerElementVariable, set=SECCONC, exportName=alphaD, result=ConcUelSDVs, location=qps, which='1;2;3;4',  values=2
*ensightPerElementVariable, set=SECCONC, exportName=alphaD, result=ConcUelSDVs, location=computed, which=average,  values=2
*ensightPerElementVariable, set=SECCONC, exportName=omega, result=ConcUelSDVs, location=qps, which='1;2;3;4',  values=4
*ensightPerElementVariable, set=SECCONC, exportName=omega, result=ConcUelSDVs, location=computed, which=average,  values=4

** ... and tensorial variables by means of a python slice!
*ensightPerElementVariable, set=SECCONC, exportName=stress, result=ConcUelSDVs, location=qps, which='1;2;3;4',  values=6:12
*ensightPerElementVariable, set=SECCONC, exportName=stress, result=ConcUelSDVs, location=computed, which=average,  values=6:12
*ensightPerElementVariable, set=SECCONC, exportName=strain, result=ConcUelSDVs, location=qps, which='1;2;3;4',  values=12:18
*ensightPerElementVariable, set=SECCONC, exportName=strain, result=ConcUelSDVs, location=computed, which=average,  values=12:18
****
** Here we access standard Abaqus CPS4 results, which has 4 integration points.
** stress and strains, and we can add them to the stress/strain collection of our UELs, so we can post-process them together in ParaView/Ensight
** However, since we have a 2D analysis, Abaqus exports only 2D stress/strain tensors with 3 components. 
** we need to fill them into a 3D Voigt tensor with 6 components, by using the f(x) feature!
*ensightPerElementVariable, set=SECSTEELLOAD,   exportName=stress, result=S, location=qps, which='1;2;3;4', f(x)='[x[0], x[1], 0, x[2], 0, 0]'
*ensightPerElementVariable, set=SECSTEELBOTTOM, exportName=stress, result=S, location=qps, which='1;2;3;4', f(x)='[x[0], x[1], 0, x[2], 0, 0]'
*ensightPerElementVariable, set=SECSTEELLOAD,   exportName=strain, result=E, location=qps, which='1;2;3;4', f(x)='[x[0], x[1], 0, x[2], 0, 0]'
*ensightPerElementVariable, set=SECSTEELBOTTOM, exportName=strain, result=E, location=qps, which='1;2;3;4', f(x)='[x[0], x[1], 0, x[2], 0, 0]'
